<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>JGum User Guide</title>

	<link rel="stylesheet" href="styles/sc-css/tutorial.css" />

	<script type="text/javascript" src="js/jquery-1.10.2.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/jquery.tableofcontents.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
	<script type="text/javascript" src="js/sc-js/jquery.sc.tutorial.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);


//]]></script>



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45485305-1', 'jgum.github.io');
  ga('send', 'pageview');

</script>

</head>




<body>



<h1>JGum User Guide</h1>

<!--
WORK IN PROGRESS....
-->

<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>




<div id="content">

  <h2>Overview</h2> 
  
  <p>
  JGum is a lightweight categorization framework for Java.
  </p>
  
  <p>
  Since ancient times, conceptual grouping is a natural human way to create abstract models of the world <sup> <a rel="footnote" href="#fn:aristo">1</a> </sup>.
  In computer science, the notion of categories plays a major role in computer programming <sup> <a rel="footnote" href="#fn:classes-vs-prototypes">2</a> </sup>.
  Particularly, different categorization mechanisms are often implicit in most programming languages (e.g., classes and packages).
  However, for statically-typed languages it is often not trivial (or not possible at all) to modify at runtime the properties of existing categories, or creating new categories on the fly.
  Furthermore, a programmer may intend to create or modify the properties of categories in a certain well-scoped context, isolating category properties, or the categories themselves, from the rest of the application.
  
  </p>
  
  JGum provides support for defining complex taxonomies of categories into a particular context.
  With JGum, a programmer can define and manipulate ad hoc categorizations, as well as easily organize categories relying on existing Java categorization mechanisms, such as classes and packages.
  

  <h2>Having Fun with Categories (or a Short Introduction to <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a>)</h2>
  
  This section illustrates a typical usage of custom categories in every day programming by means of reviewing common logging practices using a well known Java library.
  
  <h3 id="log4j-named-hierarchies">Named Hierarchies</h3>

  Popular logging libraries such as <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a> allow fine grained control on which kind of logging message (e.g., warning or error) should be processed at runtime.
  This control is enabled since programmers can easily categorize a <q>logging space</q> <sup> <a rel="footnote" href="#fn:apache-manual">3</a> </sup> according to some developer-chosen criteria.
  
  Loggers are organized hierarchically following a naming rule. For example, a logger named <code>"org"</code> is the parent of a logger named <code>"org.jgum"</code>, and the ancestor of a logger named <code>"org.jgum.JGum"</code>.
  If a logger property (e.g., a logging <code>level</code>) is not defined for a given logger, it should be resolved according to the corresponding property value of its parent.
  
  <p/>
  
  Loggers are typically defined by means of configuration files. The following fragment of a log4j configuration file configures a logger named <code>org.jgum</code> with the level <code>WARN</code>.
  
    <p><pre data-editor="properties" data-show-gutter="true">
# Set the logger level to WARN for the "org.jgum" logger
log4j.logger.org.jgum=WARN</pre></p>
  
  Although loggers can have any name, a practical convention is to name them according to the fully qualified name of the class where they are used.
  For example, a logger used in the <code>org.jgum.JGum</code> class may be
  named <code>"org.jgum.JGum"</code>. Such logger can be instantiated with:
 
   <p><pre data-editor="properties" data-show-gutter="true">Logger jgumLogger = Logger.getLogger(org.jgum.JGum.class); //instantiates a logger named "org.jgum.JGum"</pre></p> 
   
   Since this logger is a descendant from the <code>"org.jgum"</code> logger defined in the configuration file, it inherits from its parent the <code>level</code> property, set to <code>WARN</code>. 
	This is illustrated by the figure below.
    

  <div class="divImg">
    <img src="img/log4j_packages.svg" alt="Named category properties." style="padding-bottom:0.5em;" width="268" height="233" />
    <div id="imglabel:log4j_named_properties" >Fig 1. - A named category for loggers.</div>
  </div>


  <p>
  Note that in order to keep our example simple some details of log4j have been omitted.
  Particularly, the actual implementation of log4j defines <code>level</code> and other properties with default values in the root category.
  For a detailed explanation on the semantic meaning of logger properties please refer to the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>.
  </p>
  
  <p>
  This section has illustrated how a popular logging library makes use of named hierarchies to create a categorization of loggers.
  The core idea of a name based categorization is to infer hierarchical relationships between labeled categories based on a given naming convention.
  As we will see, JGum provides high level support for dealing with this categorization pattern.
  </p>
   
  <p>
  The following section motivates another kind of categorization based on the existing type hierarchies of a programming language.
  </p>
    
    
  <h3 id="log4j-type-hierarchies">Type Hierarchies</h3>
  
  <p>
  Back to our logging example, this section illustrates how log4j renders objects in logging messages.
  </p>
  
  <p>
  Since generating readable messages is a core objective of logging, log4j allows to associate custom renderers to certain classes.
  The renderers are responsible to convert instances of such classes to a convenient string representation for logging purposes.
  </p>
  
  Quoting the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>:
  <q>Object rendering follows the class hierarchy. For example, assuming oranges are fruits, if you register a <code>FruitRenderer</code>, all fruits including oranges will be rendered by the <code>FruitRenderer</code>, unless of course you registered an orange specific OrangeRenderer </q>.

  Following this example, we would like to associate a property (a renderer) to the category identified by the <code>Fruit</code> class. However, in this setting we require a different categorization heuristic: instead of categorizing a class according to its fully qualified name as in the previous section, we want to do it according to its position in a class hierarchy. This categorization is illustrated by the figure below.


  <div class="divImg">
    <img src="img/log4j_classes.svg" alt="Type category properties." style="padding-bottom:0.5em;" width="314" height="174" />
    <div id="imglabel:log4j_type_properties">Fig 2. - A type category for renderers.</div>
  </div>
  

  Therefore, this categorization relies on an existing categorization already provided by the language (a hierarchy of classes). 
  As in the previous categorization based on named hierarchies, JGum factorizes out this categorization pattern as a general mechanism to associate properties to classes and interfaces.
  As before, this association is limited to the scope of a certain context.
  

  <h2>The JGum Context</h2>
  
  JGum allows to create and maintain categorizations associated with a context.
  A JGum context can be regarded as a a register for named categorizations and a store of preferences.
  A default <a href="../apidocs/org/jgum/JGum.html">JGum context</a> can be instantiated as follows:

  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();</pre></p>

  Categorizations can be registered and retrieved as follows:

    <p><pre data-editor="java" data-show-gutter="true">
Categorization&lt;CategoryClass&gt; myCategorization = ...;
jgum.register("my-categorization", myCategorization); //registering a categorization under the identifier "my-categorization"
jgum.getCategorization("my-categorization"); //retrieving the categorization identified by "my-categorization"</pre></p>

  <p>
  This context also provides high-level methods to deal with named and type categorizations, as it will be illustrated in the next section. 
  </p>


  <h2>JGum Categories</h2> 
  
  The notion of category is a core aspect of the JGum implementation.
  A <a href="../apidocs/org/jgum/category/Category.html">JGum category</a> is defined by a group of properties shared by the objects belonging to such category.
  Categories can also be defined in terms of other categories, in which case they inherit the properties of their ancestor categories.
  Therefore, categories defines parents-children relationships with other categories.
  
  <p>JGum categories may be associated with an identifying <a href="../apidocs/org/jgum/category/LabeledCategory.html">label</a>. 
  According to the chosen categorization, this label may determine the position of the category in a hierarchy (e.g., <a href="#log4j-named-hierarchies">named hierarchies</a>), or just serve as a human aid facilitating reasoning over the category and its instances  <sup> <a rel="footnote" href="#fn:categories-matter">4</a> </sup>.
  </p>
  
  <p>
  In addition to offer a framework for creating and maintaining custom hierarchies of categories, JGum provides special classes and routines for dealing with two common categorization mechanisms.
  The rest of this section overviews the JGum support for named and type categorizations.
  </p>
  
  
  <h3>Named Categorizations</h3>

  <p>
  JGum allows to define <a href="../apidocs/org/jgum/category/named/NamedCategory.html">named categorizations</a> that structure their hierarchy according to the naming convention described in our <a rel="footnote" href="#log4j-named-hierarchies">loggers categorization example</a>.
  This categorization approach can be used to associate properties to Java packages, classes (by means of their fully qualified name) or any artifact following a similar hierarchical naming convention.
  </p>
  
  <p>
  The example below creates a named categorization with the same properties than our <a rel="footnote" href="#imglabel:log4j_named_properties">logging example</a>.
  </p>

  <p><pre data-editor="java" data-show-gutter="true">
final String LEVEL = "level";
JGum jgum = new JGum();
NamedCategory parent = jgum.forPackage(JGum.class.getPackage()); //named category for "org.jum"
NamedCategory child = jgum.forName(JGum.class.getName()); //named category for "org.jum.JGum"
parent.setProperty(LEVEL, "WARN"); //"level" property set to "WARN" for "org.jum"
assertEquals("WARN", parent.getProperty(LEVEL).get()); //"level" property is "WARN" for "org.jum"
assertEquals("WARN", child.getProperty(LEVEL).get()); //"level" property is also "WARN" for "org.jum.JGum"
assertFalse(jgum.forName("org").getProperty(LEVEL).isPresent()); //"level" property has not been set for "org"</pre></p>

  <p>
  First we obtain categories corresponding to the names <code>"org.jgum"</code> (line 3) and <code>"org.jgum.JGum"</code> (line 4). We set the <code>level</code> property to <code>WARN</code> in the <code>"org.jgum"</code> category (line 5). We verify that the property is set for both this category (line 6) and a child category that should inherit that property (line 7).
  In line 8 we verify that the property is undefined for the category <code>"org"</code>, since it is before in the hierarchy of the only category defining this property.
  </p>

  <h3>Type Categorizations</h3>

  JGum facilitates the creation of <a href="../apidocs/org/jgum/category/type/TypeCategory.html">type categorizations</a> based on the Java class hierarchy. 
  Back to our <a rel="footnote" href="#log4j-type-hierarchies">renderers categorization example</a>, considere the classes <code>Fruit</code>, <code>Orange</code> and <code>FruitRenderer</code> as:
  
    <p><pre data-editor="java" data-show-gutter="true">
public class Fruit  {...}
public class Orange extends Fruit{...}

public class FruitRenderer implements ObjectRenderer {
	@Override
	public String doRender(Object fruit) {
		...
	}
}</pre></p>
  
  
  The code below shows how the categorization illustrated in our <a rel="footnote" href="#imglabel:log4j_type_properties">rendering example</a> can be implemented in few lines of code.

  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();
TypeCategory&lt;?&gt; fruitCategory = jgum.forClass(Fruit.class); //type category for Fruit
TypeCategory&lt;?&gt; orangeCategory = jgum.forClass(Orange.class); //type category for Orange
fruitCategory.setProperty(ObjectRenderer.class, FruitRenderer.class); //ObjectRenderer property set to FruitRenderer for Fruit
assertEquals(FruitRenderer.class, fruitCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer property is FruitRenderers for Fruit
assertEquals(FruitRenderer.class, orangeCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer property is also FruitRenderer for Orange
assertFalse(jgum.forClass(Object.class).getProperty(ObjectRenderer.class).isPresent()); //ObjectRenderer property has not been set for Object</pre></p>

  <p>
  First we obtain categories corresponding to the classes <code>Fruit</code> (line 2) and <code>Orange</code> (line 3). 
  Note that a property identifier can be any object, in this case it is a class (<code>ObjectRenderer.class</code>). 
  We set the <code>ObjectRenderer</code> property to <code>FruitRenderer</code> in the <code>Fruit</code> category (line 4). We verify that the property is set for both this category (line 5) and a child category that should inherit that property (line 6).
  In line 7 we verify that the property is undefined for the category <code>Object</code>, since it is an ancestor of the only category defining this property.
  </p>
  
  
  <h2>Dealing with Multi-Inheritance</h2>

  <p>
  Previous examples showed categories inheriting the properties of a single parent category, creating tree-structured category hierarchies.
  However, other categories may be better modelled as inheriting from more than one single parent. 
  Although powerful in expresiveness <sup> <a rel="footnote" href="#fn:meyer">5</a> </sup>, multi-inheritance introduces many conceptual and technical problems <sup> <a rel="footnote" href="#fn:inheritance">6</a> </sup>. 
  </p>
  
  <p>
  The following section illustrates this with one common problematic scenario in multi-inheritance categorizations.
  </p>
  
  <h3>The Diamond Inheritance Problem</h3>

  The figure below illustrates a known problem referred as <q>diamond inheritance</q> <sup> <a rel="footnote" href="#fn:diamond-inheritance">7</a> </sup> with a simple example.
  Categories <code>B</code> and <code>C</code> inherits from <code>A</code>. They define different values for the property <code>p</code>.
  If category <code>D</code> inherits from both <code>B</code> and <code>C</code>, the value of the property <code>p</code> is ambiguous in <code>D</code> .

  <div class="divImg">
    <img src="img/diamond_inheritance.svg" alt="Diamond inheritance." style="padding-bottom:0.5em;" width="369" height="208" />
    <div id="imglabel:diamond_inheritance">Fig 3. - Diamond inheritance.</div>
  </div>

  Although there are many different alternatives to solve conflicts for ambiguous properties, unfortunately there is not a perfect one-fit-all solution <sup> <a rel="footnote" href="#fn:name-collision">8</a> </sup>.
  
  The following section illustrates the approach followed by JGum.
  
  <h3>Linearization Functions</h3>
  
  Linearization is a common approach for solving multi-inheritance conflicts <sup> <a rel="footnote" href="#fn:linearization">9</a> </sup>.
  
  In order to illustrate this approach, let's considere the following classes and interfaces defining a taxonomy of animals (example adapted from a popular Scala book <sup> <a rel="footnote" href="#fn:scala-book">10</a> </sup>) :

<p><pre data-editor="java" data-show-gutter="true">
public class Animal {}
public interface HasLegs {}
public interface FourLegged extends HasLegs {}
public interface Furry {}
public class Cat extends Animal implements Furry, FourLegged {}
public class Fish extends Animal {}</pre></p>

  
  
  <p>
  Figure 4 illustrates a JGum type categorization based on this class hierarchy.
  </p>
  

  <div class="divImg">
    <img src="img/animal_hierarchy.svg" alt="Animal hierarchy example." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy" >Fig 4. - Animal hierarchy example.</div>
  </div>
  
    <p>
  First note that JGum adds the special class <code>Any</code> at the root of the hierarchy.
  This design decision allows to have a common root for both <a href="../apidocs/org/jgum/category/type/ClassCategory.html">class</a> and <a href="../apidocs/org/jgum/category/type/InterfaceCategory.html">interface</a> type categories and this presents various advantages. One of those is being able to set global properties that are inherited by both class and interface categories in the hierarchy.
  </p>
  
  <p>
  Also observe that although in Java there is not really multi-inheritance (at least not at the time of writing), we have created a multi-inheritance type categorization based on the Java class hierarchy. 
  This is because JGum type categorizations considere, in many aspects, both classes and interfaces as same-level categorization units.
  </p>
  
  The figure also shows some properties (renderers) of two type categories.
  In order to associate those renderers to the categories <code>Animal</code> and <code>HasLegs</code>, we can write:
  
  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();
TypeCategory&lt;?&gt; animalCategory = jgum.forClass(Animal.class); //type category for Animal
TypeCategory&lt;?&gt; hasLegsCategory = jgum.forClass(HasLegs.class); //type category for HasLegs
animalCategory.setProperty(ObjectRenderer.class, AnimalRenderer.class); //setting property ObjectRenderer to AnimalRenderer in Animal
hasLegsCategory.setProperty(ObjectRenderer.class, HasLegsRenderer.class); //setting property ObjectRenderer to HasLegsRenderer in HasLegs</pre></p>

  This example provides for both non-conflictive and conflictive property resolution scenarios.
  In the simplest case, let's considere we would like to query the render property for the <code>Fish</code> category.
  Since there is only single inheritance in the category hierarchy of <code>Fish</code>, its renderer is trivially found from the first ancestor defining such property (i.e., <code>Animal</code>), as the following test illustrates:
  
    <p><pre data-editor="java" data-show-gutter="true">
...
TypeCategory&lt;?&gt; fishCategory = jgum.forClass(Fish.class); //type category for Fish
assertEquals(AnimalRenderer.class, fishCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer property is AnimalRenderer for Fish</pre></p>
  
  <p>
  However, if we ask which is the appropriate renderer for instances of <code>Cat</code>, different property resolution strategies may answer different values.
  For example, some may think that categories from super interfaces should be looked up first. In this case <code>HasLegRenderer</code> should be returned.
  Others may prefer to query first categories corresponding to the super class. In that case <code>AnimalRenderer</code> should be returned.
  </p>
  
  <p>
  Linearization helps to solve this conflict unambiguously defining a lineal order in which (super-)categories should be visited when querying a property.
  In JGum, linearization is considered a function mapping a category to a list of categories creating a search path.
  </p>
  
  The default JGum type linearization function is inspired by the linearization function used by Scala <sup> <a rel="footnote" href="#fn:scala">11</a> </sup> when solving conflicts between classes and traits.
  Therefore, JGum uses a right-first depth-first search, before eliminating all but the last occurrence of each category in the resulting list.
  
  Figure 5 illustrates the resolution order of a property starting from the category <code>Cat</code>.
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization1.svg" alt="Linearization: traversing interfaces first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization1" >Fig 5. - Linearization: Right to left (interfaces first).</div>
  </div>
  
  <p>
  The linearization function first finds this resolution order (right-first depth-first search): 
  <code>[Cat, FourLegged, HasLegs, Any, Furry, Any, Animal, Object, Any]</code> which is reduced down to <code>[Cat, FourLegged, HasLegs, Furry, Animal, Object, Any]</code> (eliminating all but the last occurrence of a redundant category).
  As the figure shows, this algorithm has the particularity that an ancestor category will not be reached until all the descendants leading to it have been explored.
  </p>
  
  <p>
  The following example verifies that the <code>ObjectRenderer</code> property is <code>HasLegsRenderer</code> for <code>Cat</code>, according to our default linearization function:
  </p>
  
    <p><pre data-editor="java" data-show-gutter="true">
...	
TypeCategory&lt;?&gt; catCategory = jgum.forClass(Cat.class); //type category for Cat
assertEquals(HasLegsRenderer.class, catCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer property is HasLegsRenderer for Cat</pre></p>


  Given that a custom linearization function may be not that trivial to implement, JGum provides simple abstractions for creating those functions from a set of parameters.
  In order to associate a type linearization function with a JGum context we can write:
  
      <p><pre data-editor="java" data-show-gutter="true">
Function&lt;TypeCategory&lt;?&gt;, List&lt;TypeCategory&lt;?&gt;&gt;&gt; linearizationFunction = 
		new BottomUpTypeTraversalPolicy( 
		SearchStrategy.PRE_ORDER, //pre-order search
		Priority.INTERFACES_FIRST, //look first at interfaces, then classes
		InterfaceOrder.REVERSE, //traverse the interfaces from right to left (reverse declaration order)
		RedundancyCheck.KEEP_LAST); //if a category appears more than once in the linearization, keep the last found and discard the previous ones.
JGum jgum = new JGum(linearizationFunction);</pre></p>
        
  The previous linearization function is the same than the default linearization function for type categories: right to left search, looking at interfaces first.
  
  Alternatively, we could have configured a different linearization function, say a left to right search, looking at classes first:
  
      <p><pre data-editor="java" data-show-gutter="true">
Function&lt;TypeCategory&lt;?&gt;, List&lt;TypeCategory&lt;?&gt;&gt;&gt; linearizationFunction = 
		new BottomUpTypeTraversalPolicy(
		SearchStrategy.PRE_ORDER, //pre-order search
		Priority.CLASSES_FIRST, //look first at classes, then interfaces
		InterfaceOrder.DECLARATION, //traverse the interfaces from left to right (declaration order)
		RedundancyCheck.KEEP_LAST); //if a category appears more than once in the linearization, keep the last found and discard the previous ones.
JGum jgum = new JGum(linearizationFunction);</pre></p>
  
  Figure 6 illustrates the alternative resolution order defined by our custom linearization function.
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization2.svg" alt="Linearization: traversing classes first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization2" >Fig 6. - Linearization: Left to right (classes first).</div>
  </div>
  
  This function first finds this resolution order: 
  <code>[Cat, Animal, Object, Any, Furry, Any, FourLegged, HasLegs, Any]</code> which is reduced down to <code>[Cat, Animal, Object, Furry, FourLegged, HasLegs, Any]</code>.
  In this setting, the renderer for instances of <code>Cat</code> is <code>AnimalRenderer</code>, since it is found earlier in the list of categories returned by the linearization function.

	
 
 
 
<!--
  <h2>Miscelaneous Features</h2>

  <h3>Iterating on property values in a categorization</h3>
  
  <h3>Category creation listeners</h3>
-->

  <h2>Ad Hoc Categorizations</h2>

  Of course, you can always create simple ad hoc categorizations if you do not care about named and type categorizations.
  The example below implements a simple diamond inheritance hierarchy. 
  For ad hoc categorizations, the default linearization function is depth first, left to right (i.e., following the natural ordering of the parents). Conflicts are solved keeping the last redundant category in the linearization and dropping the rest.
  
    <p><pre data-editor="java" data-show-gutter="true">
//creating a simple hierarchy
Categorization mySimpleCategorization = new Categorization();
Category grandFather = new Category(mySimpleCategorization); //the root of the hierarchy
Category parent1 = new Category(asList(grandFather)); //parent1 inherits from grandFather
Category parent2 = new Category(asList(grandFather)); //parent2 also inherits from grandFather
Category child = new Category(asList(parent1, parent2)); //child inherits from both parent1 and parent2
		
//setting properties
grandFather.setProperty("p1", "x"); //setting property "p1" to "x" in grandFather
parent1.setProperty("p1", "y"); //overridden property "p1" as "y" in parent1
parent2.setProperty("p1", "z"); //overridden property "p1" as "z" in parent2
parent2.setProperty("p2", "x"); //setting property "p2" to "x" in parent2
		
//testing
assertEquals("y", child.getProperty("p1").get()); //"p1" property found in parent1
assertEquals("x", child.getProperty("p2").get()); //"p2" property found in parent2
		
//optionally registering the previous categorization in a JGum context
JGum jgum = new JGum();
jgum.register("my-categorization", mySimpleCategorization);</pre></p>



  <h2>Limitations and Future Work</h2>

  This section highlights certain limitations of JGum. In certain cases, future work directions to overcome these limitations are outlined.

  <h3>Named Categorizations Limitations</h3>
  <p>
  JGum provides support for only one pattern of named categorizations: hierarchies specified by means of category names implicitly containing a list of ancestors using dots as token separator.
  However, many other alternatives are possible (e.g., structuring hierarchies based on a numeric pattern present in the name of a category).
  The current mechanism was chosen because it is well known and understood. Other strategies should not be difficult to implement.
  </p>
  
  <h3>Type Categorizations Limitations</h3>
  <p>
  JGum type categories currently do not take into consideration implicit reflective properties (e.g., fields and methods declarations) of the wrapped classes that define a type categorization.
  Instead, existing classes are just considered category identifiers and provide a hierarchical organization for type categorizations.
  This may change in the future if a good use-case appears.
  </p>
  
  <h3>Alternative Conflict Resolution Mechanisms</h3>
  <p>
  As mentioned before, linearization is only one mechanism to solve conflicts in multi-inheritance scenarios. 
  For example, an alternative mechanism allowing to rename one of the conflictive properties in an descendant type category may be implemented, or somehow given the possibility to the programmer to explicitly decide which inherited property to choose.
  </p>
  
  <p>
  At the moment, there are no plans to implement any of these alternative conflict resolution mechanisms since they are not part of the requirements that motivated the implementation of JGum.
  </p>
  
  <h3>Performance Issues</h3>
  <p>
  A potential performance issue may occur in scenarios with many categories deep in a hierarchy.
  For example, if many of those categories do not contain properties (or only contain properties that are not queried often), the property look up algorithm has to continuously traverse a long list of non interesting nodes.
  This may be solved adding on each category references not only to its parents, but to the next ancestors actually containing properties.
  In this line, it may also make sense to implement a sort of indexing based on certain frequently queried properties. In other words, a category may keep a reference to the next category with a particular often-queried property.
  This optimization algorithms may make the querying of properties more efficient despite a small overhead in the addition of new properties.
  </p>
  
  <p>
  Alternatively, for rather static categorizations that do not modify much their properties, it may also make sense to pre-process its categories, in such a way that a category has a local copy of all its inherited properties according to a linearization function.
  </p>

  
  <h2>Conclusions</h2>

  This tutorial has described a lightweight Java library for creating different kind of categorizations: 1) named, 2) type and 3) ad hoc categorizations.
  
  <p>
  Not all the JGum features have been discussed here. Features such as top-down traversing of hierarchies, registration of listeners in categorizations and the description of utility classes facilitating common tasks have been left out for timing constraints. 
  </p>
  Particularly, top-down search has interesting applications. For example, with JGum is easy to find, given a type categorization, the first implementor of an interface (say using breadth-first search) that has certain desired characteristics (e.g., also implements the <code>Serializable</code> interface). This feature may be described in a next version of this tutorial.
  
   <p>
  If you are interested to know more about such features, or would like to know how to extend JGum to support other user-defined categorizations, please <a href="#contact" title="Contact the author">contact</a> the author.
  </p>
  
  
  <h2>License</h2>

  JGum is open source, distributed under the terms of this <a href="https://github.com/jgum/jgum/blob/master/LICENSE.txt" title="License">license</a>.
  
  
  <h2>Try it !</h2>

  JGum sources are available at <a href="https://github.com/jgum/jgum" title="JGum at GitHub">GitHub</a>.
  <p/>
  In case you are using Maven, it is also available at the <a href="https://oss.sonatype.org/index.html#nexus-search;quick~jgum" title="JGum at the Sonatype Spanshots repository">Sonatype Spanshots repository</a>. Just add this dependency to your POM to include JGum into your project.

    <p><pre data-editor="xml" data-show-gutter="true">
&lt;dependency&gt;
  &lt;groupId&gt;com.github.jgum&lt;/groupId&gt;
  &lt;artifactId&gt;jgum&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-alpha-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</pre></p>

  You may also find interesting taking a look to the <a href="../apidocs/index.html">JGum API documentation</a>.

  <h2 id="contact">Contact</h2>
  
  Constructive feedback and criticism, questions or a wish list can be sent to <em>[uclouvain(dot)be (that symbol for emails) sergio(dot)castro]</em> (inversing the order).
  Or just write me a line if you want to say hello ! :-)
  
</div> <!-- end of content -->

    
    
<div id="footnotes">
  <hr />
  
  <h3>Footnotes</h3>
  
  <ol>
  
  <li id="fn:aristo">
  	The complete works of Aristotle. Barnes, J. (ed). Volume 1. (the revised Oxford translation), Princeton University Press. 1984.
  </li>
  
  <li id="fn:classes-vs-prototypes">
  	Classes vs. Prototypes - Some Philosophical and Historical Observations. Antero Taivalsaari. Journal of Object-Oriented Programming. 1996.
  </li>
  
  <li id="fn:apache-manual">
  	<a href="http://logging.apache.org/log4j/1.2/manual.html">Short introduction to log4j.</a>  Ceki Gülcü, March 2002.
  </li>
  
  <li id="fn:categories-matter">
  	The conceptual grouping effect: Categories matter (and named categories matter more). Gary Lupyan. Cognition, Vol. 108, No. 2. August 2008.
  </li>

  <li id="fn:meyer">
  	Object Oriented Software Construction. Bertrand Meyer. August 1997.
  </li>
  
  <li id="fn:inheritance">
  	On the Notion of Inheritance. Antero Taivalsaari. ACM Computing Surveys, Vol. 28, pages 438 - 479. 1996.
  </li>
  
  <li id="fn:diamond-inheritance">
    The programming language Jigsaw: Mixins, modularity and multiple inheritance. Bracha, G. Ph.D. thesis, Univ. of Utah, March 1992. 
  </li>
  
  <li id="fn:name-collision">
    Name Collision in Multiple Classification Hierarchies. Knudsen. European Conference on Object-Oriented Programming, Oslo, Norway. August 1988.
  </li>
  
  <li id="fn:linearization">
    Proposal for a Monotonic Multiple Inheritance Linearization. Roland Ducournau, Michel Habib, Marianne Huchard, and Marie-Laure Mugnier. OOPSLA, page 164-175. ACM. 1994.
  </li>  
  
  <li id="fn:scala-book">
    Programming in Scala. Martin Odersky, Lex Spoon and Bill Venners. Artima Press, Mountain View, CA. 2 edition. January 2011.
  </li>
  
  <li id="fn:scala">
    An Overview of the Scala Programming Language. Martin Odersky, and al.. IC/2004/64. EPFL Lausanne, Switzerland. 2004.
  </li>
  
  </ol>
  
</div> <!-- end of footnotes -->

</body>
</html>
