<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>JGum User Guide</title>

	<link rel="stylesheet" href="styles/sc-css/tutorial.css" />
    
     <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45393106-1', 'github.com');
  ga('send', 'pageview');
    </script>

	<script type="text/javascript" src="js/jquery-1.10.2.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/jquery.tableofcontents.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
	<script type="text/javascript" src="js/sc-js/jquery.sc.tutorial.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);

//]]></script>



</head>




<body>



<h1>JGum User Guide</h1>

<!--
WORK IN PROGRESS....
-->

<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>




<div id="content">

  <h2>Overview</h2> 
  
  Since ancient times, conceptual grouping is a natural human way to create abstract models of the world <sup> <a rel="footnote" href="#fn:aristo">1</a> </sup>.
  In computer science, the notion of categories plays a major role in computer programming <sup> <a rel="footnote" href="#fn:classes-vs-prototypes">2</a> </sup>.
  Particularly, different categorization mechanisms are often implicit in most programming languages (e.g., classes and packages).
  However, for statically-typed languages it is often not trivial (or not possible at all) to modify at runtime the properties of existing categories, or creating new categories on the fly.
  Furthermore, a programmer may intend to create or modify the properties of categories in a certain well-scoped context, isolating category properties, or the categories themselves, from the rest of the application.
  
  <p/>
  
  JGum is a Java library providing support for defining categories and their properties in a particular context.
  With JGum, a programmer can define and manage custom hierarchies of categories, or easily create categories based on existing Java categorization mechanisms, such as classes and packages.
  

  <h2>Having Fun with Categories (or a short introduction to <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a>)</h2>
  
  This section illustrates typical usage of custom categories in every day programming by means of reviewing common logging practices using a well known Java library.
  
  <h3 id="log4j-named-hierarchies">Named Hierarchies</h3>

  Popular logging libraries such as <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a> allow fine grained control on which kind of logging message (e.g., warning or error) should be processed at runtime.
  This control is enabled since programmers can easily categorize a <q>logging space</q> <sup> <a rel="footnote" href="#fn:apache-manual">3</a> </sup> according to some developer-chosen criteria.
  
  Loggers are organized hierarchically following a naming rule. For example, a logger named <code>org</code> is the parent of a logger named <code>org.jgum</code>, and the ancestor of a logger named <code>org.jgum.JGum</code>.
  If a logger property (e.g., a logging <code>level</code>) is not defined for a given logger, it should be resolved according to the corresponding property value of its parent.
  
  <p/>
  
  Loggers are typically defined by means of configuration files. The following fragment of a log4j configuration file configures a logger named <code>org.jgum</code> with the level <code>WARN</code>.
  
    <p><pre data-editor="properties" data-show-gutter="true">
# Set the logger level to warning for the org.jgum package
log4j.logger.org.jgum=WARN</pre></p>
  
  Although loggers can have any name, a common convention is to name them according to the fully qualified name of the class where they are used.
  For example, a logger named <code>"org.jgum.JGum"</code> can be instantiated with:
 
   <p><pre data-editor="properties" data-show-gutter="true">Logger jgumLogger = Logger.getLogger(org.jgum.JGum.class); //instantiates a logger named "org.jgum.JGum"</pre></p> 
   
   Since this logger is a descendant from the <code>"org.jgum"</code> logger defined in the configuration file, it inherits from its parent the <code>level</code> property, set to <code>WARN</code>. 
	This is illustrated by the figure below.
    

  <div class="divImg">
    <img src="img/log4j_packages.svg" alt="Named category properties." style="padding-bottom:0.5em;" width="268" height="233" />
    <div id="imglabel:log4j_named_properties" >Fig 1. - Named category properties.</div>
  </div>


  <p>
  Note that although it is not showed in the figure, the actual implementation of log4j defines <code>level</code> and other properties with default values in the root category.
  For a detailed explanation on the semantic meaning of logger properties please refer to the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>.
  </p>
  
  <p>
  This section has illustrated how a popular logging library makes use of named hierarchies to create a categorization of loggers.
  The core idea of a name based categorization is to infer hierarchical relationships between labeled categories based on a given naming convention.
  As we will se soon, JGum provides high level support for dealing with this categorization pattern.
  </p>
   
  <p>
  The following section motivates another kind of categorization based on the existing type hierarchies of a programming language.
  </p>
    
    
  <h3 id="log4j-type-hierarchies">Type Hierarchies</h3>
  
  Back to our logging example, this section illustrates how log4j render objects in logging messages.
  Since generating readable messages is a core objective of logging, log4j allows to associate custom renderers to certain classes.
  The renderers are responsible to convert a given object to a convenient string representation for logging.
  
  <p/>
  
  Quoting the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>:
  <q>Object rendering follows the class hierarchy. For example, assuming oranges are fruits, if you register a <code>FruitRenderer</code>, all fruits including oranges will be rendered by the <code>FruitRenderer</code>, unless of course you registered an orange specific OrangeRenderer </q>.

  Then, we would like to associate a property (a renderer) to the category identified by the <code>Fruit</code> class. However, in this case we require a different categorization heuristic: instead of categorizing a class according to its fully qualified name as before, we want to do it according to its location in a class hierarchy. This categorization is illustrated by the figure below.


  <div class="divImg">
    <img src="img/log4j_classes.svg" alt="Type category properties." style="padding-bottom:0.5em;" width="314" height="174" />
    <div id="imglabel:log4j_type_properties">Fig 2. - Type category properties.</div>
  </div>
  

  Therefore, this categorization is based on an existing categorization already provided by the language (a hierarchy of classes). 
  
  <p/>
  This section has showed how log4j relies on the existing type hierarchy of the language to create a categorization of renderers.
  As in the previous categorization based on name hierarchies, JGum factorizes out this categorization pattern as a general mechanism to associate properties to classes and interfaces based on their position on a class hierarchy.
  As before, JGum allows to add and manipulate new properties (i.e., not existing in the original type categorization provided by the language) in the scope of a certain context.
  
  

  <h2>The JGum Context</h2>
  
  JGum allows to create and maintain categorizations associated with a context.
  A new <a href="../apidocs/org/jgum/JGum.html">JGum context</a> can be instantiated as follows:

  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();</pre></p>

  This context allows to register new categorizations and retrieve them later by name, like in the example below:

    <p><pre data-editor="java" data-show-gutter="true">
Categorization&lt;CategoryClass&gt; myCategorization = ...;
jgum.register("my-categorization", myCategorization); //registering a categorization under the identifier "my-categorization"
jgum.getCategorization("my-categorization"); //retrieving the categorization identified by "my-categorization"</pre></p>

  <p>The next section describes how to create and manipulate named and type categorizations.</p>


  <h2>JGum Categories</h2> 
  
  The notion of category is a core aspect of the JGum implementation.
  A <a href="../apidocs/org/jgum/category/Category.html">JGum category</a> is defined by a group of properties shared by the objects belonging to such category.
  Categories can also be defined in terms of other categories, in which case they inherit the properties of their ancestor categories.
  Therefore, categories defines parents-children relationships with other categories.
  
  <p>JGum categories may be associated with an identifying label. 
  According to the chosen categorization, this label may determine the position of the category in the hierarchy, or just serve as a human aid for facilitating reasoning over a category and its instances  <sup> <a rel="footnote" href="#fn:categories-matter">4</a> </sup>.
  </p>
  
  <p>
  In addition to offer a framework for creating and maintaining custom hierarchies of categories, JGum provides special classes and routines for dealing with two common categorization mechanisms.
  The rest of this section overviews the JGum support for named and type categorizations.
  </p>
  
  
  <h3>Named Categorizations</h3>

  <p>
  JGum allows to define named categorizations that structure their hierarchy according to the same naming convention showed in our <a rel="footnote" href="#log4j-named-hierarchies">loggers categorization example</a>.
  This categorization approach can be used to associate properties to packages, classes (by means of their fully qualified name) or any artifact following a similar hierarchical naming convention.
  </p>
  
  <p>
  The example below creates a named categorization with the same properties of our <a rel="footnote" href="#imglabel:log4j_named_properties">logging example</a>.
  </p>

  <p><pre data-editor="java" data-show-gutter="true">
@Test
public void testNamedCategoryInheritance() {
	final String LEVEL = "level";
	JGum jgum = new JGum();
	NamedCategory parent = jgum.forPackage(JGum.class.getPackage()); //named category for "org.jum"
	NamedCategory child = jgum.forName(JGum.class.getName()); //named category for "org.jum.JGum"
	parent.setProperty(LEVEL, "WARN"); //"level" property set to "WARN" for "org.jum"
	assertEquals("WARN", parent.getProperty(LEVEL).get()); //"level" property is "WARN" for "org.jum"
	assertEquals("WARN", child.getProperty(LEVEL).get()); //"level" property is also "WARN" for "org.jum"
	assertFalse(jgum.forName("org").getProperty(LEVEL).isPresent()); //"level" property has not been set for "org"
}</pre></p>

  <p>
  First we obtain categories corresponding to the names <code>"org.jgum"</code> (line 5) and <code>"org.jgum.JGum"</code> (line 6). We set the <code>level</code> property to <code>warn</code> in the <code>"org.jgum"</code> category (line 7). We verify that the property is set for both this category (line 8) and a descendant category that should inherit that property (line 9).
  In line 10 we verify that the property is undefined for the category <code>"org"</code>, since it is an ancestor of the only category defining this property.
  </p>

  <h3>Type Categorizations</h3>

  JGum facilitates the creation of categorizations based on the Java class hierarchy. 
  Back to our <a rel="footnote" href="#log4j-type-hierarchies">renderers categorization example</a>, considere the classes <code>Fruit</code>, <code>Orange</code> and <code>FruitRenderer</code> as:
  
    <p><pre data-editor="java" data-show-gutter="true">
public class Fruit  {...}
public class Orange extends Fruit{...}

public class FruitRenderer implements ObjectRenderer {
	@Override
	public String doRender(Object fruit) {
		...
	}
}</pre></p>
  
  
  The code below shows how the categorization illustrated in our <a rel="footnote" href="#imglabel:log4j_type_properties">rendering example</a> can be implemented in few lines of code.

  <p><pre data-editor="java" data-show-gutter="true">
@Test
public void testTypeCategoryInheritance() {
	JGum jgum = new JGum();
	TypeCategory<?> fruitCategory = jgum.forClass(Fruit.class); //type category for Fruit.class
	TypeCategory<?> orangeCategory = jgum.forClass(Orange.class); //type category for Orange.class
	fruitCategory.setProperty(ObjectRenderer.class, FruitRenderer.class); //ObjectRenderer.class property set to FruitRenderer.class for Fruit.class
	assertEquals(FruitRenderer.class, fruitCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer.class property is FruitRenderer.class for Fruit.class
	assertEquals(FruitRenderer.class, orangeCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer.class property is also FruitRenderer.class for Orange.class
	assertFalse(jgum.forClass(Object.class).getProperty(ObjectRenderer.class).isPresent()); //ObjectRenderer.class property has not been set for Object.class
}</pre></p>

  <p>
  First we obtain categories corresponding to the classes <code>Fruit.class</code> (line 4) and <code>Orange.class</code> (line 5). 
  Note that a property identifier can be any object, in this case we set the <code>ObjectRenderer.class</code> property to <code>fruitRenderer</code> in the <code>Fruit.class</code> category (line 6). We verify that the property is set for both this category (line 7) and a descendant category that should inherit that property (line 8).
  In line 9 we verify that the property is undefined for the category <code>Object.class</code>, since it is an ancestor of the only category defining this property.
  </p>
  
  
  <h2>Multi-inheritance Categorizations</h2>

  Previous examples illustrates categories inheriting the properties of a single parent category, creating tree-structured category hierarchies.
  However, other categories may be better modelled as inheriting from more than one single parent <sup> <a rel="footnote" href="#fn:meyer">5</a> </sup>. 
  Although powerful in expresiveness, multi-inheritance introduces many conceptual and technical problems <sup> <a rel="footnote" href="#fn:inheritance">6</a> </sup>. 
  
  The following section illustrates this with one common problematic scenario in multi-inheritance categorizations.
  
  <h3>The Diamond Inheritance Problem</h3>

  The figure below illustrates a problem referred as <q>diamond inheritance</q> <sup> <a rel="footnote" href="#fn:diamond-inheritance">7</a> </sup> with a simple example.
  Categories <code>B</code> and <code>C</code> inherits from <code>A</code>. They define different values for the property <code>p</code>.
  If category <code>D</code> inherits from both <code>B</code> and <code>C</code>, the value of this property in <code>D</code> is ambiguous.

  <div class="divImg">
    <img src="img/diamond_inheritance.svg" alt="Diamond inheritance." style="padding-bottom:0.5em;" width="369" height="208" />
    <div id="imglabel:diamond_inheritance">Fig 3. - Diamond inheritance.</div>
  </div>

  Although there are many different mechanisms to solve this kind of multi-inheritance problem, unfortunately there is not a perfect one-fit-all solution<sup> <a rel="footnote" href="#fn:name-collision">8</a> </sup>.
  
  The following section illustrates the approach followed by JGum.
  
  <h3>Linearization Functions</h3>
  
  Linearization is a common approach for solving multi-inheritance conflicts <sup> <a rel="footnote" href="#fn:linearization">9</a> </sup>.
  
  In order to illustrate this approach, let's considere the following classes and interfaces defining a taxonomy of animals.

<p><pre data-editor="java" data-show-gutter="true">
public class Animal {}
public interface HasLegs {}
public interface FourLegged extends HasLegs {}
public interface Furry {}
public class Cat extends Animal implements Furry, FourLegged {}
public class Fish extends Animal {}</pre></p>

  
  
  <p>
  Figure 4 illustrates a JGum type categorization based on this class hierarchy.
  First note that JGum adds the special class <code>Any</code> at the root of the hierarchy.
  This design decision allows to have a common root for both class and interface type categories.
  </p>
  
  <p>
  Also observe that although in Java there is not really multi-inheritance (at least at the time of writing), we have created a multi-inheritance type categorization based on the Java class hierarchy classes. 
  This is because JGum typed categorizations considere, in many aspects, both classes and interfaces as similar categorization units.
  </p>

  <div class="divImg">
    <img src="img/animal_hierarchy.svg" alt="Animal hierarchy example." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy" >Fig 4. - Animal hierarchy example.</div>
  </div>
  
  In order to associate renderers to the type categories <code>Animal</code> and <code>HasLegs</code> as illustrated in the figure, we can write:
  
  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();
TypeCategory<?> animalCategory = jgum.forClass(Animal.class); //type category for Animal.class
animalCategory.setProperty(ObjectRenderer.class, AnimalRenderer.class); //ObjectRenderer.class property is AnimalRenderer.class for Animal.class
TypeCategory<?> hasLegsCategory = jgum.forClass(HasLegs.class); //type category for HasLegs.class
hasLegsCategory.setProperty(ObjectRenderer.class, HasLegsRenderer.class); //ObjectRenderer.class property is HasLegsRenderer.class for HasLegs.class</pre></p>

  This scenario provides for both non-conflictive and conflictive property resolution problems.
  In the simplest case, let's considere we would like to query the render property for the type category <code>Fish</code>.
  Since there is only single inheritance in the category hierarchy of <code>Fish</code>, its renderer is trivially found from the first ancestor defining such property, as the following test illustrates:
  
    <p><pre data-editor="java" data-show-gutter="true">
...
TypeCategory<?> fishCategory = jgum.forClass(Fish.class); //type category for Fish.class
assertEquals(AnimalRenderer.class, fishCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer.class property is AnimalRenderer.class for Fish.class</pre></p>
  
  However, if we ask which is the appropriate renderer for instances of <code>Cat</code>, different property resolution strategies will answer different values.
  For example, some may think that categories from implemented interfaces should be looked up first. In this case <code>HasLegRenderer</code> should be returned.
  Others may prefer to query first categories corresponding super classes. In that case <code>AnimalRenderer</code> should be returned.
  
  Linearization helps to solve this conflict unambiguously defining a lineal order in which (super-)categories should be visited when querying a property.
  
  The default type linearization function is inspired in the linearization function used by Scala. JGum uses a right-first depth first search. 
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization1.svg" alt="Linearization: traversing interfaces first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization1" >Fig 5. - Linearization: Right to left (interfaces first).</div>
  </div>
  
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization2.svg" alt="Linearization: traversing classes first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization2" >Fig 6. - Linearization: Left to right (classes first).</div>
  </div>
  
  
  
  


Wikipedia:
"Scala resolves method names using a right-first depth-first search of extended 'traits', before eliminating all but the last occurrence of each module in the resulting list. So, the resolution order is: [D, C, A, B, A], which reduces down to [D, C, B, A]."
	<a rel="footnote" href="#fn:scala">10</a> </sup>.
 
 This algorithm has the advantage that an ancestor category will not be reached until all the desdendants leading to it has been explored.
 
<!--
  <h2>Miscelaneous Features</h2>

  <h3>Iterating on property values in a categorization</h3>
  
  <h3>Category creation listeners</h3>
-->

  <h2>Ad hoc categorizations</h2>

  Of course, you can always create simple ad hoc categorizations if you do not care about named and type categorizations.
  The example below illustrates a simple diamond inheritance hierarchy. 
  Properties are found according to the default linearization algorithm explained in previous sections.
  
    <p><pre data-editor="java" data-show-gutter="true">
//creating a simple categorization
Category grandFather = new Category(new Categorization<>()); //the root of the hierarchy
Category parent1 = new Category(asList(grandFather)); //parent1 inherits from grandFather
Category parent2 = new Category(asList(grandFather)); //parent2 also inherits from grandFather
Category child = new Category(asList(parent1, parent2)); //child inherits from both parent1 and parent2
		
//setting properties
grandFather.setProperty("p1", "x"); //setting property "p1" to "x" in grandFather
parent1.setProperty("p1", "y"); //overridden property "p1" as "y" in parent1
parent2.setProperty("p1", "z"); //overridden property "p1" as "z" in parent2
parent2.setProperty("p2", "x"); //setting property "p2" to "x" in parent2

//testing	
assertEquals("y", child.getProperty("p1").get()); //"p1" property found in parent1
assertEquals("x", child.getProperty("p2").get()); //"p2" property found in parent2</pre></p>



  <h2>Limitations and Future Work</h2>
  
  <p>
  JGum type categories currently do not take into account existing properties (attributes and methods) of the wrapped classes that define a type categorization.
  Instead, existing classes are just considered category identifiers.
  This is because the use cases that motivated the implementation of JGum did not require such features. However, this may change on the future.
  </p>
  
  <h3>Alternative Property Resolution Mechanisms</h3>
  <p>
  As mentioned before, linearization is only one mechanism to solve conflict in multi-inheritance scenarios. 
  For example, a mechanism for renaming properties may be implemented in case of conflicts, or somehow given the possibility to the programmer to explicitly choose which inherited property to choose. 
  </p>
  
  <p>
  At the moment, there are no any plans to implement any of these alternative conflict resolution mechanisms since they are not part of the requirements that motivated the implementation of JGum.
  </p>
  
  <h3>Performance Issues</h3>
  <p>
  A potential performance issue may occur in scenarios with many categories deep in a hierarchy, with few of those categories actually containing properties.
  This may be solved in the future adding on each category references not only to its parents, but to the next ancestors actually containing properties.
  In this line, it may also make sense to implement a sort of indexing based on certain frequently queried properties. In other words, a category may keep a reference to the next category with a particular often-queried property.
  This algorithms will make the querying of properties more efficient despite a small overhead in the addition of new properties.
  </p>
  
  <p>
  Alternatively, for categorizations that do not modify much their properties, it may also make sense to pre-process its categories, in such a way that a category has a local copy of all its inherited properties.
  </p>

  
  <h2>Conclusions</h2>

  Although JGum can be extended to support other user-defined categorizations, this topic has been left out of the scope of this tutorial.

  <h2>License</h2>

  JGum is open source, distributed under the terms of this <a href="https://github.com/jgum/jgum/blob/master/LICENSE.txt" title="License">license</a>.
  
  
  <h2>Try it !</h2>

  JGum sources are available at <a href="https://github.com/jgum/jgum" title="JGum at GitHub">GitHub</a>.
  <p/>
  In case you are using Maven, it is also available at the <a href="https://oss.sonatype.org/index.html#nexus-search;quick~jgum" title="JGum at the Sonatype Spanshots repository">Sonatype Spanshots repository</a>. Just add this dependency to your POM to include JGum into your project.

    <p><pre data-editor="xml" data-show-gutter="true">
&lt;dependency&gt;
  &lt;groupId&gt;com.github.jgum&lt;/groupId&gt;
  &lt;artifactId&gt;jgum&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-alpha-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</pre></p>

  You may also find interesting taking a look to the <a href="../apidocs/index.html">JGum API documentation</a>.

  <h2>Contact</h2>
  
  Constructive feedback and criticism, questions or a wish list can be sent to <em>[uclouvain(dot)be (that symbol for emails) sergio(dot)castro]</em> (inversing the order).
  Or just write me a line if you want to say hello ! :-)
  
</div> <!-- end of content -->

    
    
<div id="footnotes">
  <hr />
  
  <h3>Footnotes</h3>
  
  <ol>
  
  <li id="fn:aristo">
  	The complete works of Aristotle. Barnes, J. (ed). Volume 1. (the revised Oxford translation), Princeton University Press. 1984.
  </li>
  
  <li id="fn:classes-vs-prototypes">
  	Classes vs. Prototypes - Some Philosophical and Historical Observations. Antero Taivalsaari. Journal of Object-Oriented Programming. 1996.
  </li>
  
  <li id="fn:apache-manual">
  	<a href="http://logging.apache.org/log4j/1.2/manual.html">Short introduction to log4j.</a>  Ceki Gülcü, March 2002.
  </li>
  
  <li id="fn:categories-matter">
  	The conceptual grouping effect: Categories matter (and named categories matter more). Gary Lupyan. Cognition, Vol. 108, No. 2. August 2008.
  </li>

  <li id="fn:meyer">
  	Object Oriented Software Construction. Bertrand Meyer. August 1997.
  </li>
  
  <li id="fn:inheritance">
  	On the Notion of Inheritance. Antero Taivalsaari. ACM Computing Surveys, Vol. 28, pages 438 - 479. 1996.
  </li>
  
  <li id="fn:diamond-inheritance">
    The programming language Jigsaw: Mixins, modularity and multiple inheritance. Bracha, G. Ph.D. thesis, Univ. of Utah, March 1992. 
  </li>
  
  <li id="fn:name-collision">
    Name Collision in Multiple Classification Hierarchies. Knudsen. European Conference on Object-Oriented Programming, Oslo, Norway. August 1988.
  </li>
  
  <li id="fn:linearization">
    Proposal for a Monotonic Multiple Inheritance Linearization. Roland Ducournau, Michel Habib, Marianne Huchard, and Marie-Laure Mugnier. OOPSLA, page 164-175. ACM. 1994.
  </li>  
  
  <li id="fn:scala">
    Programming in Scala. Martin Odersky, Lex Spoon and Bill Venners. Artima Press, Mountain View, CA. 2 edition. January 2011.
  </li>
  
  </ol>
  
</div> <!-- end of footnotes -->

</body>
</html>
