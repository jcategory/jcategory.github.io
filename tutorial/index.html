<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>JGum User Guide</title>

	<link rel="stylesheet" href="styles/sc-css/tutorial.css" />
    
     <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45393106-1', 'github.com');
  ga('send', 'pageview');
    </script>

	<script type="text/javascript" src="js/jquery-1.10.2.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/jquery.tableofcontents.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/ace-builds/src-noconflict/ace.js" charset="utf-8"></script>
	<script type="text/javascript" src="js/sc-js/jquery.sc.tutorial.js" charset="utf-8"></script>
    
    <script type="text/javascript">//<![CDATA[
  (function ($) {
    $(document).ready(function(){
		
      $('#table_of_content_entries').tableOfContents('#content', {startLevel:2, depth: 3});
      $.prettifyCodeSnippets("eclipse");
      //$.prettifyCodeSnippets("solarized_light");
      $.configureFootnotes();

    })

  })(jQuery);

//]]></script>



</head>




<body>



<h1>JGum User Guide</h1>

<!--
WORK IN PROGRESS....
-->

<div id="table_of_content">
  <strong>Contents</strong>
  <ol id="table_of_content_entries"></ol>
</div>




<div id="content">

  <h2>Overview</h2> 
  
  Since ancient times, conceptual grouping is a natural human way to create abstract models of the world <sup> <a rel="footnote" href="#fn:aristo">1</a> </sup>.
  In computer science, the notion of categories plays a major role in computer programming <sup> <a rel="footnote" href="#fn:classes-vs-prototypes">2</a> </sup>.
  Particularly, different categorization mechanisms are often implicit in most programming languages (e.g., classes and packages).
  However, for statically-typed languages it is often not trivial (or not possible at all) to modify at runtime the properties of existing categories, or creating new categories on the fly.
  Furthermore, a programmer may intend to create or modify the properties of categories in a certain well-scoped context, isolating category properties, or the categories themselves, from the rest of the application.
  
  <p/>
  
  JGum is a Java library providing support for defining categories and their properties in a particular context.
  With JGum, a programmer can define and manage custom hierarchies of categories, or easily create categories based on existing Java categorization mechanisms, such as classes and packages.
  

  <h2>Having Fun with Categories (or a short introduction to <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a>)</h2>
  
  This section illustrates typical usage of custom categories in every day programming by means of reviewing common logging practices using a well known Java library.
  
  <h3 id="log4j-named-hierarchies">Named Hierarchies</h3>

  Popular logging libraries such as <a href="http://logging.apache.org/log4j/1.2/" title="Apache log4j">log4j</a> allow fine grained control on which kind of logging message (e.g., warning or error) should be processed at runtime.
  This control is enabled since programmers can easily categorize a <q>logging space</q> <sup> <a rel="footnote" href="#fn:apache-manual">3</a> </sup> according to some developer-chosen criteria.
  
  Loggers are organized hierarchically following a naming rule. For example, a logger named <code>org</code> is the parent of a logger named <code>org.jgum</code>, and the ancestor of a logger named <code>org.jgum.JGum</code>.
  If a logger property (e.g., a logging <code>level</code>) is not defined for a given logger, it should be resolved according to the corresponding property value of its parent.
  
  <p/>
  
  Loggers are typically defined by means of configuration files. The following fragment of a log4j configuration file configures a logger named <code>org.jgum</code> with the level <code>WARN</code>.
  
    <p><pre data-editor="properties" data-show-gutter="true">
# Set the logger level to warning for the org.jgum package
log4j.logger.org.jgum=WARN</pre></p>
  
  Although loggers can have any name, a common convention is to name them according to the fully qualified name of the class where they are used.
  For example, a logger named <code>"org.jgum.JGum"</code> can be instantiated with:
 
   <p><pre data-editor="properties" data-show-gutter="true">Logger jgumLogger = Logger.getLogger(org.jgum.JGum.class); //instantiates a logger named "org.jgum.JGum"</pre></p> 
   
   Since this logger is a descendant from the <code>"org.jgum"</code> logger defined in the configuration file, it inherits from its parent the <code>level</code> property, set to <code>WARN</code>. 
	This is illustrated by the figure below.
    

  <div class="divImg">
    <img src="img/log4j_packages.svg" alt="Named category properties." style="padding-bottom:0.5em;" width="268" height="233" />
    <div id="imglabel:log4j_named_properties" >Fig 1. - Named category properties.</div>
  </div>


  <p>
  Note that although it is not showed in the figure, the actual implementation of log4j defines <code>level</code> and other properties with default values in the root category.
  For a detailed explanation on the semantic meaning of logger properties please refer to the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>.
  </p>
  
  <p>
  This section has illustrated how a popular logging library makes use of named hierarchies to create a categorization of loggers.
  The core idea of a name based categorization is to infer hierarchical relationships between labeled categories based on a given naming convention.
  As we will se soon, JGum provides high level support for dealing with this categorization pattern.
  </p>
   
  <p>
  The following section motivates another kind of categorization based on the existing type hierarchies of a programming language.
  </p>
    
    
  <h3 id="log4j-type-hierarchies">Type Hierarchies</h3>
  
  Back to our logging example, this section illustrates how log4j render objects in logging messages.
  Since generating readable messages is a core objective of logging, log4j allows to associate custom renderers to certain classes.
  The renderers are responsible to convert a given object to a convenient string representation for logging.
  
  <p/>
  
  Quoting the <a href="http://logging.apache.org/log4j/1.2/manual.html">log4j manual</a>:
  <q>Object rendering follows the class hierarchy. For example, assuming oranges are fruits, if you register a <code>FruitRenderer</code>, all fruits including oranges will be rendered by the <code>FruitRenderer</code>, unless of course you registered an orange specific OrangeRenderer </q>.

  Then, we would like to associate a property (a renderer) to the category identified by the <code>Fruit</code> class. However, in this case we require a different categorization heuristic: instead of categorizing a class according to its fully qualified name as before, we want to do it according to its location in a class hierarchy. This categorization is illustrated by the figure below.


  <div class="divImg">
    <img src="img/log4j_classes.svg" alt="Type category properties." style="padding-bottom:0.5em;" width="314" height="174" />
    <div id="imglabel:log4j_type_properties">Fig 2. - Type category properties.</div>
  </div>
  

  Therefore, this categorization is based on an existing categorization already provided by the language (a hierarchy of classes). 
  
  <p/>
  This section has showed how log4j relies on the existing type hierarchy of the language to create a categorization of renderers.
  As in the previous categorization based on name hierarchies, JGum factorizes out this categorization pattern as a general mechanism to associate properties to classes and interfaces based on their position on a class hierarchy.
  As before, JGum allows to add and manipulate new properties (i.e., not existing in the original type categorization provided by the language) in the scope of a certain context.
  
  

  <h2>The JGum Context</h2>
  
  JGum allows to create and maintain categorizations associated with a context.
  A new <a href="../apidocs/org/jgum/JGum.html">JGum context</a> can be instantiated as follows:

  <p><pre data-editor="java" data-show-gutter="true">
JGum jgum = new JGum();</pre></p>

  This context allows to register new categorizations and retrieve them later by name, like in the example below:

    <p><pre data-editor="java" data-show-gutter="true">
Categorization&lt;CategoryClass&gt; myCategorization = ...;
jgum.register("my-categorization", myCategorization); //registering a categorization under the identifier "my-categorization"
jgum.getCategorization("my-categorization"); //retrieving the categorization identified by "my-categorization"</pre></p>

  <p>The next section describes how to create and manipulate named and type categorizations.</p>


  <h2>JGum Categories</h2> 
  
  The notion of category is a core aspect of the JGum implementation.
  A <a href="../apidocs/org/jgum/category/Category.html">JGum category</a> is defined by a group of properties shared by the objects belonging to such category.
  Categories can also be defined in terms of other categories, in which case they inherit the properties of their ancestor categories.
  Therefore, categories defines parents-children relationships with other categories.
  
  <p>JGum categories may be associated with an identifying label. 
  According to the chosen categorization, this label may determine the position of the category in the hierarchy, or just serve as a human aid for facilitating reasoning over a category and its instances  <sup> <a rel="footnote" href="#fn:categories-matter">4</a> </sup>.
  </p>
  
  <p>
  In addition to offer a framework for creating and maintaining custom hierarchies of categories, JGum provides special classes and routines for dealing with two common categorization mechanisms.
  The rest of this section overviews the JGum support for named and type categorizations.
  </p>
  
  
  <h3>Named Categorizations</h3>

  <p>
  JGum allows to define named categorizations that structure their hierarchy according to the same naming convention showed in our <a rel="footnote" href="#log4j-named-hierarchies">loggers categorization example</a>.
  This categorization approach can be used to associate properties to packages, classes (by means of their fully qualified name) or any artifact following a similar hierarchical naming convention.
  </p>
  
  <p>
  The example below creates a named categorization with the same properties of our <a rel="footnote" href="#imglabel:log4j_named_properties">logging example</a>.
  </p>

  <p><pre data-editor="java" data-show-gutter="true">
@Test
public void testNamedCategoryInheritance() {
	final String LEVEL = "level";
	JGum jgum = new JGum();
	NamedCategory parent = jgum.forPackage(JGum.class.getPackage()); //named category for "org.jum"
	NamedCategory child = jgum.forName(JGum.class.getName()); //named category for "org.jum.JGum"
	parent.setProperty(LEVEL, "WARN"); //"level" property set to "WARN" for "org.jum"
	assertEquals("WARN", parent.getProperty(LEVEL).get()); //"level" property is "WARN" for "org.jum"
	assertEquals("WARN", child.getProperty(LEVEL).get()); //"level" property is also "WARN" for "org.jum"
	assertFalse(jgum.forName("org").getProperty(LEVEL).isPresent()); //"level" property has not been set for "org"
}</pre></p>

  <p>
  First we obtain categories corresponding to the names <code>"org.jgum"</code> (line 5) and <code>"org.jgum.JGum"</code> (line 6). We set the <code>level</code> property to <code>warn</code> in the <code>"org.jgum"</code> category (line 7). We verify that the property is set for both this category (line 8) and a descendant category that should inherit that property (line 9).
  In line 10 we verify that the property is undefined for the category <code>"org"</code>, since it is an ancestor of the only category defining this property.
  </p>

  <h3>Type Categorizations</h3>

  JGum facilitates the creation of categorizations based on the Java class hierarchy. 
  Back to our <a rel="footnote" href="#log4j-type-hierarchies">renderers categorization example</a>, considere the classes <code>Fruit</code>, <code>Orange</code> and <code>FruitRenderer</code> as:
  
    <p><pre data-editor="java" data-show-gutter="true">
public class Fruit  {...}
public class Orange extends Fruit{...}

public class FruitRenderer implements ObjectRenderer {
	@Override
	public String doRender(Object fruit) {
		...
	}
}</pre></p>
  
  
  The code below shows how the categorization illustrated in our <a rel="footnote" href="#imglabel:log4j_type_properties">rendering example</a> can be implemented in few lines of code.

  <p><pre data-editor="java" data-show-gutter="true">
@Test
public void testTypeCategoryInheritance() {
	JGum jgum = new JGum();
	TypeCategory<?> fruitCategory = jgum.forClass(Fruit.class); //type category for Fruit.class
	TypeCategory<?> orangeCategory = jgum.forClass(Orange.class); //type category for Orange.class
	fruitCategory.setProperty(ObjectRenderer.class, FruitRenderer.class); //ObjectRenderer.class property set to FruitRenderer.class for Fruit.class
	assertEquals(FruitRenderer.class, fruitCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer.class property is FruitRenderer.class for Fruit.class
	assertEquals(FruitRenderer.class, orangeCategory.getProperty(ObjectRenderer.class).get()); //ObjectRenderer.class property is also FruitRenderer.class for Orange.class
	assertFalse(jgum.forClass(Object.class).getProperty(ObjectRenderer.class).isPresent()); //ObjectRenderer.class property has not been set for Object.class
}</pre></p>

  <p>
  First we obtain categories corresponding to the classes <code>Fruit.class</code> (line 4) and <code>Orange.class</code> (line 5). 
  Note that a property identifier can be any object, in this case we set the <code>ObjectRenderer.class</code> property to <code>fruitRenderer</code> in the <code>Fruit.class</code> category (line 6). We verify that the property is set for both this category (line 7) and a descendant category that should inherit that property (line 8).
  In line 9 we verify that the property is undefined for the category <code>Object.class</code>, since it is an ancestor of the only category defining this property.
  </p>
  
  
  <h2>Multi-inheritance Categorizations</h2>

  Previous examples illustrates categories inheriting the properties of a single parent category, creating tree-structured category hierarchies.
  However, other categories may be better modelled as inheriting from more than one single parent <sup> <a rel="footnote" href="#fn:meyer">5</a> </sup>. 
  Although powerful in expresiveness, multi-inheritance introduces many conceptual and technical problems <sup> <a rel="footnote" href="#fn:inheritance">6</a> </sup>. 
  
  The following section illustrates this with one common problematic scenario in multi-inheritance categorizations.
  
  <h3>The Diamond Inheritance Problem</h3>

  The figure below illustrates a problem referred as <q>diamond inheritance</q> <sup> <a rel="footnote" href="#fn:diamond-inheritance">7</a> </sup> with a concrete example.
  Categories <code>B</code> and <code>C</code> inherits from <code>A</code>. They define different values for the property <code>p</code>.
  If category <code>D</code> inherits from both <code>B</code> and <code>C</code>, the value of this property in <code>D</code> is ambiguous.

  <div class="divImg">
    <img src="img/diamond_inheritance.svg" alt="Diamond inheritance." style="padding-bottom:0.5em;" width="369" height="208" />
    <div id="imglabel:diamond_inheritance">Fig 3. - Diamond inheritance.</div>
  </div>

  Although there are many different mechanisms to solve this kind of multi-inheritance problem, unfortunately there is not a perfect one-fit-all solution<sup> <a rel="footnote" href="#fn:name-collision">8</a> </sup>.
  
  The following section illustrates the approach followed by JGum.
  
  <h3>Linearization Functions</h3>
  
  Linearization is a common approach for solving multi-inheritance conflicts <sup> <a rel="footnote" href="#fn:linearization">9</a> </sup>.
  It defines a lineal order in which (super-)categories should be visited when querying a property.



  <div class="divImg">
    <img src="img/animal_hierarchy.svg" alt="Animal hierarchy example." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy" >Fig 4. - Animal hierarchy example.</div>
  </div>
  
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization1.svg" alt="Linearization: traversing interfaces first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization1" >Fig 5. - Linearization: traversing interfaces first.</div>
  </div>
  
  
  <div class="divImg">
    <img src="img/animal_hierarchy_linearization2.svg" alt="Linearization: traversing classes first." style="padding-bottom:0.5em;" width="559" height="250" />
    <div id="imglabel:animal_hierarchy_linearization2" >Fig 6. - Linearization: traversing classes first.</div>
  </div>
  
  
  
  


Wikipedia:
"Scala resolves method names using a right-first depth-first search of extended 'traits', before eliminating all but the last occurrence of each module in the resulting list. So, the resolution order is: [D, C, A, B, A], which reduces down to [D, C, B, A]."
	<a rel="footnote" href="#fn:scala">10</a> </sup>.
 
 
<!--
  <h2>Miscelaneous Features</h2>

  <h3>Iterating on property values in a categorization</h3>
  
  <h3>Category creation listeners</h3>
-->

  <h2>Limitations and Future Work</h2>
  
  <p>
  JGum type categories currently do not take into account existing properties (attributes and methods) of the wrapped classes that define a type categorization.
  Instead, existing classes are just considered category identifiers.
  This is because the use cases that motivated the implementation of JGum did not require such features. However, this may change on the future.
  </p>
  
  <p>
  A potential performance issue may occur in scenarios with many categories deep in a hierarchy, with few of those categories actually containing properties.
  For single inheritance hierarchies, this may be easily solved with categories containing references not only to its parent category,
  but to the next ancestor actually containing a property. This will make the query of properties more efficient despite a small overhead in the addition of new properties.
  However, this algorithm does not seem trivial to implement in multi-inheritance hierarchies, taking into consideration the different linearization strategies supported by JGum.
  
  </p>
  
  <h2>Conclusions</h2>

  Although JGum can be extended to support other user-defined categorizations, this topic has been left out of the scope of this tutorial.

  <h2>License</h2>

  JGum is open source, distributed under the terms of this <a href="https://github.com/jgum/jgum/blob/master/LICENSE.txt" title="License">license</a>.
  
  
  <h2>Try it !</h2>

  JGum sources are available at <a href="https://github.com/jgum" title="JGum at GitHub">GitHub</a>.
  <p/>
  In case you are using Maven, it is also available at the <a href="https://oss.sonatype.org/index.html#nexus-search;quick~jgum" title="JGum at the Sonatype Spanshots repository">Sonatype Spanshots repository</a>. Just add this dependency to your POM to include JGum into your project.

    <p><pre data-editor="xml" data-show-gutter="true">
&lt;dependency&gt;
  &lt;groupId&gt;com.github.jgum&lt;/groupId&gt;
  &lt;artifactId&gt;jgum&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-alpha-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</pre></p>

  You may also find interesting taking a look to the <a href="../apidocs/index.html">JGum API documentation</a>.

  <h2>Contact</h2>
  
  Constructive feedback and criticism, questions or a wish list can be sent to <em>[uclouvain(dot)be (that symbol for emails) sergio(dot)castro]</em> (inversing the order).
  Or just write me a line if you want to say hello ! :-)
  
</div> <!-- end of content -->

    
    
<div id="footnotes">
  <hr />
  
  <h3>Footnotes</h3>
  
  <ol>
  
  <li id="fn:aristo">
  	The complete works of Aristotle. Barnes, J. (ed). Volume 1. (the revised Oxford translation), Princeton University Press. 1984.
  </li>
  
  <li id="fn:classes-vs-prototypes">
  	Classes vs. Prototypes - Some Philosophical and Historical Observations. Antero Taivalsaari. Journal of Object-Oriented Programming. 1996.
  </li>
  
  <li id="fn:apache-manual">
  	<a href="http://logging.apache.org/log4j/1.2/manual.html">Short introduction to log4j.</a>  Ceki Gülcü, March 2002.
  </li>
  
  <li id="fn:categories-matter">
  	The conceptual grouping effect: Categories matter (and named categories matter more). Gary Lupyan. Cognition, Vol. 108, No. 2. August 2008.
  </li>

  <li id="fn:meyer">
  	Object Oriented Software Construction. Bertrand Meyer. August 1997.
  </li>
  
  <li id="fn:inheritance">
  	On the Notion of Inheritance. Antero Taivalsaari. ACM Computing Surveys, Vol. 28, pages 438 - 479. 1996.
  </li>
  
  <li id="fn:diamond-inheritance">
    The programming language Jigsaw: Mixins, modularity and multiple inheritance. Bracha, G. Ph.D. thesis, Univ. of Utah, March 1992. 
  </li>
  
  <li id="fn:name-collision">
    Name Collision in Multiple Classification Hierarchies. Knudsen. European Conference on Object-Oriented Programming, Oslo, Norway. August 1988.
  </li>
  
  <li id="fn:linearization">
    Proposal for a Monotonic Multiple Inheritance Linearization. Roland Ducournau, Michel Habib, Marianne Huchard, and Marie-Laure Mugnier. OOPSLA, page 164-175. ACM. 1994.
  </li>  
  
  <li id="fn:scala">
    Programming in Scala. Martin Odersky, Lex Spoon and Bill Venners. Artima Press, Mountain View, CA. 2 edition. January 2011.
  </li>
  
  </ol>
  
</div> <!-- end of footnotes -->

</body>
</html>
